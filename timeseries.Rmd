---
title: "Time Series Analysis"
author: "Evangelidakis Leandros"
output: github_document

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}

library(tsbox)
library(astsa)
library(forecast)
library(lubridate)
library(zoo)
```
# Άσκηση 1

Τα στοιχεία του πίνακα παρουσιάζουν τις πωλήσεις μπύρας μίας βιομηχανίας (σε εκατομμύρια μπουκάλια) ανά περιοχή από το 2016 μέχρι το 2019

```{r}
years<-c(2016,2017,2018,2019)
data<-c(1,3,6,4,2,2,7,5,2,4,8,5,1,3,8,6)
matrix_data<-matrix(data,nrow=4,byrow=T)
beer_sales<-ts(data,start=c(2016,1),end=c(2019,4),frequency=4)
beer_sales
```

I.Να γίνει εξάλειψη της εποχικότητας και να υπολογιστούν οι εποχιακές δείκτες
αυτών των δεδομένων

II.Να κατασκευάσετε τη γραμμή τάσης

III.Να προσδιορίσετε την κυκλική μεταβολή με τη μέθοδο των σχετικών κυκλικών
καταλοίπων


## I

Αρχικά παρουσιάζουμε τη χρονοσειρά γραφικά.

```{r}
tsplot(beer_sales, type="o", ylab="Millions of bottles",main="Beer sales")
```


Όπως βλέπουμε, από χρόνο σε χρόνο, οι πωλήσεις έχουν αυξητική τάση μέχρι τα μέσα περίπου της χρονιάς και μετά φθίνουσα μέχρι το τέλος.

Στη συνέχεια θα υπολογίσουμε τους εποχιακούς δείκτες.

Πρώτα υπολογίζουμε τον κινητό μέσο όρο 1ης τάξης 4 όρων (Moving average) και τους μέσους όρους κάθε τριμήνου.

```{r}
M<-ma(beer_sales,4)
matrix<-matrix(M,nrow=4,byrow=T)
M
```

Έπειτα υπολογίζουμε την ποσότητα $K_i =(M_i + M_{i+1})/2$

```{r}
avg<-c()
matrix_M<-as.matrix(M)

for(i in 3:13){
  avg<-c(avg,(matrix_M[i]+matrix_M[i+1])/2)
}
avg
```

Και την ποσότητα $(Y_{i+2} / K_i)*100$

```{r}
org_data<-c(1,3,6,4,2,2,7,5,2,4,8,5,1,3,8,6)
z<-c()
for (i in 1:11){
    z<-c(z,(org_data[i+2]/avg[i])*100)

}
z
z<-matrix(c(NA,NA,z,NA,NA,NA),nrow=4,byrow=T)
z
```

Μένει να υπολογίσουμε τους ποσοστιαίους μέσους όρους των εποχών.

Παρακάτω φαίνονται οι αδιόρθωτοι δείκτες και το άθροισμά τους

```{r}
season_avg<-colMeans(z,na.rm = T)
season_avg
s<-sum(season_avg)
s
```

Για τον υπολογισμό του διορθωτικού συντελεστή χρησιμοποιούμε τον τύπο $Διορθωτικός Συντελεστής = 400 / Άθροισμα Μέσων Όρων$

```{r}
adj<-400/s
adj
```

Οι τελικοί δείκτες εποχικότητας υπολογίζοντας διαιρώντας τις αδιόρθωτες τιμές που πήραμε από τους μέσους όρους, με τον παραπάνω συντελεστή.

```{r}
seasonal_indexes<-season_avg*adj
seasonal_indexes
```

Επαλήθευση ότι το άθροισμά τους κάνει 400

```{r}
sum(seasonal_indexes)
```


Τώρα θα διαιρέσουμε κάθε καταχώρηση με τον αντίστοιχο εποχιακό δείκτη.

```{r}
deseasoned_2016<-matrix_data[,1]/(seasonal_indexes[1]/100)
deseasoned_2017<-matrix_data[,2]/(seasonal_indexes[2]/100)
deseasoned_2018<-matrix_data[,3]/(seasonal_indexes[3]/100)
deseasoned_2019<-matrix_data[,4]/(seasonal_indexes[4]/100)
deseasoned_data<-matrix(cbind(deseasoned_2016,deseasoned_2017,deseasoned_2018,deseasoned_2019),nrow=4,byrow=F)
```

Μετά την εξάλειψη της εποχικότητας τα δεδομένα έχουν ως εξής:

```{r}
deseasoned_data
```

```{r}
deseasoned_data<-ts(array(t(deseasoned_data)),start=c(2016,1),end=c(2019,4),frequency=4)
deseasoned_data
```

Παρακάτω βλέπουμε τα νέα δεδομένα συγκριτικά με την αρχική χρονοσειρά.

```{r}
ts.plot(beer_sales,deseasoned_data,type='o',main='Beer sales - Deseasonalized data',gpars = list(col=c('black','red')))
grid (lty = 1)
```

Και τα Deseasonalized δεδομένα ξεχωριστά

```{r}
tsplot(deseasoned_data, type="o", ylab="Millions of bottles",main="Beer sales Deseasonalized",margins=1)
```

## II

Στη συνέχεια θα υπολογίσουμε την εξίσωσης της Τάσης 

```{r}
tsplot(deseasoned_data, type="o", ylab="Millions of bottles",main="Beer sales Deseasonalized",margins=1)
fit <- tslm(deseasoned_data ~ trend)
lines(fit$fitted.values,col='darkred')
fit
text(2018,3.5,expression(y == 3.43382 + 0.08137*x),col='darkred')

```

## II

Για την κυκλική μεταβολή υπολογίζουμε τα σχετικά κυκλικά κατάλοιπα από τον τύπο: $100 * (y- \hat y)/ \hat y$, όπου $\hat y$ οι εκτιμήσεις από την τάση.

```{r}
cyclical<-100*((beer_sales-fit$fitted.values)/fit$fitted.values)
cyclical
tsplot(cyclical, main="Cyclical residuals",type="o",ylab=expression((y-hat(y) / hat(y)) * 100),margins=1)
grid (lty = 1)
lines(fit$fitted.values,col='darkred')
text(2017,16,'Trend line',col='darkred')

```





# Άσκηση 2

Στον επόμενο πίνακα δίνονται οι εισπράξεις από τις ετήσιες πωλήσεις (σε χιλ.ευρώ) μία βιομηχανίας


```{r}
income<-c(37.44,44.14,46.25,43.99,51.84,49.10,58.56,58.02,70.28)
yearly_income<-ts(income,start=2011,end=2019,frequency=1)
yearly_income
```


I. Να γίνει εξάλειψη της εποχικότητας και να υπολογιστούν οι εποχιακές δείκτες
αυτών των δεδομένων

ΙΙ. Να κατασκευάσετε τη γραμμή τάσης

ΙΙΙ. Να προσδιορίσετε την κυκλική μεταβολή με τη μέθοδο των σχετικών κυκλικών
καταλοίπων


## I
Τα δεδομένα έχουν μόνο τις ετήσιες τιμές και συνεπώς μόνο η μακροχρόνια τάση, η κυκλική μεταβολή και η ακανόνιστη μεταβολή λαμβάνονται υπόψη, καθώς η εποχιακή μεταβολή κάνει ένα κύκλο στη διάρκεια του έτους.

Αρχικά παρουσιάζουμε γραφικά τη χρονοσειρά.

```{r}
tsplot(yearly_income, type="o", ylab="Thousands of Euros",main="Yearly income")

```

## II
Στη συνέχεια υπολογίζουμε την τάση

```{r}
tsplot(yearly_income, type="o", ylab="Thousands of Euros",main="Yearly income")
fit <- tslm(yearly_income ~ trend)
lines(fit$fitted.values,col='darkred')
fit
text(2015,55,expression(y == 34.175 + 3.379*x),col='darkred')

```

## III
Έπειτα υπολογίζουμε τα σχετικά κυκλικά κατάλοιπα από τον τύπο $100*(Y- \hat Y) / \hat Y$

```{r}

cyclical<-100*((yearly_income-fit$fitted.values)/fit$fitted.values)
cyclical
tsplot(cyclical, main="Relative Cyclical residuals",type="o",ylab=expression((y-hat(y) / hat(y)) * 100),margins=1)
grid (lty = 1)
fit2 <- tslm(cyclical ~ trend)
lines(fit2$fitted.values,col='darkred')
fit
text(2012.2,0,expression(y == 34.175 + 3.379*x),col='darkred')

```



# Άσκηση 3

www.bankofcanada.ca the daily USD/CAD exchange rates for the last 2 years

I.Plot the time series

II.Βρείτε την ευθεία της τάσης με γραμμική παλινδρόμηση και κάντε το κοινό γράφημα

III.Βρείτε quadratic trend και κάντε πάλι το γράφημα

IV.Υπολογίστε τις πρώτες και δεύτερες διαφορές και κάντε τα αντίστοιχα γραφήματα

V.Κάντε μία πρόβλεψη με ένα από τα παραπάνω μοντέλα (4) για τις επόμενες 22 μέρες.

VI.Προσθέστε μία εποχική συνιστώσα (π.χ. την επίδραση του Ιανουαρίου) στην γραμμική τάση (φτιάξτε μία binary μεταβλητή που θα δείχνει αν το exchange rate
είναι από το Γενάρη ή όχι) Κάντε fit το μοντέλο με την επίδραση του Γενάρη.(hint : χρησιμοποιείστε τη συνάρτηση format to convert the dates to strings)

VII.Κάνετε fit a quadratic trend θεωρώντας και την επίδραση του Γενάρη

VIII.Κανετε το γράφημα διασποράς μεταξύ των τιμών exchange rates and the lagged values

IX.Υπολογίστε την αυτοσυσχέτιση r_1 υστέρησης 1. Τι παρατηρείτε?

X.Φτιάξτε μια συνάρτηση (ονομάστε την cal AC(y,k) που θα υπολογίζει την αυτοσυσχέτιση υστέρισης k γενικά για μία χρονοσειρά

XI.Στα παραπάνω δεδομένα φτιάξτε το ΑR(1) και MA(1) μοντέλο

ΑR(1)=ARIMA(1,0,0)

MA(1)=ARIMA(0,0,1)

XII.Συγκρίνετε τα παραπάνω δύο μοντέλα με το ARIMA(2,1,2).Υπολογίστε τα ΜΑΕ (MEAN ABSOLUTE ERROR), mse, mape

## Ι

Αρχικά κατεβάζουμε τα δεδομένα σε αρχείο csv από την ιστοσελίδα που μας δίνεται. Έπειτα, καθότι το αρχείο περιέχει περιττές πληροφορίες στις πρώτες γραμμές του, τις αφαιρούμε χειροκίνητα και κρατάμε μόνο τα δεδομένα. Επίσης η R διαβάζει λάθος την πρώτη τιμή γιαυτό την αντικαθιστούμε με την σωστή, όπως φαίνεται παρακάτω.

```{r}

data <- read.csv("FXUSDCAD-2016-12-30-ed-2019-01-01.csv",header=F,stringsAsFactors = F )
data[1,1]<-"03-01-17"
data$V1<-as.Date(format(as.Date(data$V1,"%d-%m-%y")),"20%y-%m-%d")
head(data)
```

Έπειτα μετατρέπουμε τη χρονοσειρά σε Time - Series αντικείμενο χρησιμοποιώντας τη βιβλιοθήκη zoo αλλά και τη βιβλιοθήκη tsbox. 

```{r}
ts_data_1 <- read.zoo(data)
ts_data_2<-ts_ts(ts_data.table(data))
tsplot(ts_data_2,main='Daily Exchange rate',ylab='')
```

## ΙΙ

Για την τάση χρησιμοποιούμε τη βιλιοθήκη forecast και συγκεκριμένα την εντολή tslm()

Γραμμική παλινδρόμηση για υπολογισμό της Τάσης :


```{r}
tsplot(ts_data_2,main='USD Daily Exchange rate, Linear Trend',ylab='')
fit <- tslm(ts_data_2 ~ trend)
lines(fit$fitted.values,col='darkred')
fit
text(2017.8,1.31,expression(y == 1.3012540 -0.0000113*x),col='darkred')
```

Η ευθεία της Τάσης είναι $y=1.301254-0.0000113x$

## ΙΙΙ

Στη συνέχεια κάνουμε πολυωνυμική παλινδρόμηση

```{r}
tsplot(ts_data_2,main='Daily Exchange rate, Quadratic Trend',ylab='')
fit2 <- tslm(ts_data_2 ~ poly(trend,2))
lines(fit2$fitted.values,col='darkred')
fit2
text(2018,1.32,expression(y == 1.29711 -0.04896*x +0.64460*x^2),col='darkred')
```

H εξίσωση του πολυωνύμου είναι η $y= 1.29711-0.04896x+0.64460x^2$

## ΙV

Υπολογισμός πρώτων και δεύτερων διαφορών χρησιμοποιώντας την εντολή lag() του πακέτου stats

<b>Πρώτες Διαφορές</b>

```{r}
first_dif<-ts_diff(ts_data_2)
sec_dif<-ts_diff(first_dif)
ts_plot(first_dif,title = "First Differences")
```

```{r}
head(first_dif)
```

<b>Δεύτερες Διαφορές</b>

```{r}
ts_plot(sec_dif,title = "Second Differences")
```

```{r}
head(sec_dif)
```

<b>Πρώτες και Δεύτερες Διαφορές</b>
```{r}
ts_plot(first_dif,sec_dif,title='First and Second Differences')
```

## V

Για την πρόβλεψη θα χρησιμοποιήσουμε το πολυωνυμικό μοντέλο και το πακέτο forecast() με το οποίο κάνουμε τις προβλέψεις που φαίνονται στο παρακάτω γράφημα.Η μέθοδος υπολογίζει αυτόματα και διαστήματα εμπιστοσύνης 95% και 80%.

<b>Προβέψεις</b>

```{r}
forecast(fit2, h=22)
```

<b>Γραφική Απεικόνιση</b>

```{r}
plot(forecast(fit2, h=22),main="Forecasts from Quadratic model",xlab="Time",ylab="Exchange Rate")
```


## VI


Εδώ μας ζητείται να προσθέσουμε ως εποχική συνιστώσα την επίδραση του Ιανουαρίου.

Αρχικά αντιστοιχούμε με κάθε ημερομηνία την τιμές 0 και 1 ανάλογα αν αυτή αντιστοιχεί στον Ιανουάριο.

```{r}
jan<-replicate(length(data$V1), 0)
for (i in 1:length(jan)) {
  if (format(data$V1[i], "%m")=="01"){
    jan[i]<-c(1)
  }
}
```

## VII

Στο παρακάτω γράφημα φαίνεται η νέα καμπύλη με την επίδραση του Ιανουαρίου.Η εξίσωσή της είναι 
$$ y = 1.29999 -0.10153x +0.55641x^2 -0.03286j, j \in {0,1} $$

Επιπλέον παρουσιάζουμε και την αρχική πολυωνυμική καμπύλη που είχαμε υπολογίσει σε προηγούμενο ερώτημα για σύγκριση των δύο μοντέλων.


```{r}
par(mar = c(5, 5, 5, 5))
plot(data$V1,data$V2,type='l',main='Daily Exchange Rate \n Quadratic Trend with seasonal index of January',xlab='Date',ylab='')
fit<-lm( V2 ~ poly(V1,2) + jan, data=data)
fit
lines(data$V1,fit$fitted.values,col='red',type='l')
text(data$V1[300],data$V2[80],expression(y == 1.29999 -0.10153*x +0.55641*x^2 -0.03286*j),col='darkred')
grid()

```

```{r echo=FALSE}
tsplot(ts_data_2,main='Daily Exchange rate, Quadratic Trend',ylab='')
fit2 <- tslm(ts_data_2 ~ poly(trend,2))
lines(fit2$fitted.values,col='darkred')
fit2
text(2018,1.32,expression(y == 1.29711 -0.04896*x +0.64460*x^2),col='darkred')
```

## VIII

Στα παρακάτω γραφήματα φαίνονται η αρχική χρονοσειρά και τα δεδομένα με υστέρηση μίας και δύο ημερών.

<b>Υστέρηση μίας ημέρας</b>
```{r}
ts_plot(ts_data_1,lag(ts_data_1,1), title='Original Data and Lagged(1 day)')
```

<b>Υστέρηση δύο ημερών</b>
```{r}
ts_plot(ts_data_1,lag(ts_data_1,2), title='Original Data and Lagged(2 days)')
```



## IX


Για τον συντελεστή αυτοσυσχέτισης, υπολογίζουμε το lag για 1 ημέρα και στη συνέχεια το συντελεστή συσχέτισης της χρονοσειράς με το lag. Αππορίπτουμε της NA τιμές που προκύπτουν.

```{r}
lag1 <- lag(ts_data_1, 1, na.pad=T)
acf_1<-cor(ts_data_1[!is.na(lag1)], lag1[!is.na(lag1)])
```

Έτσι ο συντελεστής αυτοσυσχέτισης είναι:

```{r}
acf_1
```

Παρατηρούμε ότι υπάρχει μεγάλη συσχέτιση (98.92%) μεταξύ των δεδομένων και αυτών της προηγούμενης ημέρας.


## Χ

Φτιάχνουμε μια συνάρτηση που δέχεται ως είσοδο μια χρονοσειρά και ένα ακέραιο και επιστρέφει την αυτοσυσχέτιση με υστερήσεις από 1 έως k.

```{r}
acf_k<-c()
AC<-function(y,k){
  for(i in 1:k){
    lag_k <- lag(y, i, na.pad=T)
    acf_k<-c(acf_k,cor(y[!is.na(lag_k)], lag_k[!is.na(lag_k)]))
  }
acf_k
}
```


Εφαρμόζοντας τη συνάρτηση στα δεδομένα για k=5 έχουμε:

```{r}
AC(ts_data_1,5)
```
Βλέπουμε ότι η μεγαλύτερη συσχέτιση παρουσιάζεται για τα δεδομένα της προηγούμενης ημέρας,ενώ μειώνεται γραμμικά με την αύξηση του k 


## ΧΙ

Για τα μοντέλα ARIMA χρησιμοποιούμε το πακέτο forecast


<b>ARIMA(1,0,0)</b>

```{r}
fit1 <- Arima(ts_data_1, order=c(1,0,0))
fit1
checkresiduals(fit)
```


<b>ARIMA(2,0,0)</b>

```{r}
fit2 <- Arima(ts_data_1, order=c(0,0,1))
fit2
checkresiduals(fit2)

```

## ΧΙΙ

<b>ARIMA(2,1,2)</b>

```{r}
fit3 <- Arima(ts_data_1, order=c(2,1,2))
fit3
checkresiduals(fit3)

```

Οι δείκτες <u>AIC</u> έχουν ως εξής:

<b>
Arima(1,0,0): -3766.82 <br>
Arima(0,0,1): -2320.96 <br>
Arima(2,1,2): -3763.45 <br>
</b>

Όπως φαίνεται το πρώτο μοντέλο έχει λίγο μικρότερο AIC από το τρίτο ενώ το δεύτερο αρκετά μεγαλύτερο.

Παρακάτω φαίνονται τα MAE,MSE,MAPE για κάθε μοντέλο:

```{r}
print('Arima(1,0,0)')
accuracy(fit1)
print('Arima(0,0,1)')
accuracy(fit2)
print('Arima(2,1,2)')
accuracy(fit3)

```

<u>Mean Absolute Error (MAE):</u>

```{r}
mae1<-accuracy(fit1)[3]
mae2<-accuracy(fit2)[3]
mae3<-accuracy(fit3)[3]
barplot(c(mae3,mae1,mae2),width = 1,main="Mean Absolute Error",names.arg = c("Arima(2,1,2)","Arima(1,0,0)","Arima(0,0,1)"))
```


<u>Mean Squared Error (MSE):</u>

```{r}
mse1<-accuracy(fit1)[2]^2
mse2<-accuracy(fit2)[2]^2
mse3<-accuracy(fit3)[2]^2
barplot(c(mse3,mse1,mse2),width = 1,main="Mean Squared Error",names.arg = c("Arima(2,1,2)","Arima(1,0,0)","Arima(0,0,1)"))
```

Το πρώτο μοντέλο έχει λίγο μεγαλύτερο MSE από το τρίτο ενώ το δεύτερο πολύ μικρότερο.

<u>Mean Absolute Percentage Error (MAPE):</u>

Το πρώτο μοντέλο έχει λίγο μεγαλύτερο MAPE από το τρίτο ενώ το δεύτερο αρκετά μεγαλύτερο.

```{r}
mape1<-accuracy(fit1)[5]
mape2<-accuracy(fit2)[5]
mape3<-accuracy(fit3)[5]
barplot(c(mape3,mape1,mape2),width = 1,main="Mean Absolute Percentage Error",names.arg = c("Arima(2,1,2)","Arima(1,0,0)","Arima(0,0,1)"))
```
